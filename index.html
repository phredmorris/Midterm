<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Terms of Service</title>
    <!-- Load Tailwind CSS for utility styling. This makes styling the app much faster. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define custom CSS for visual enhancements and fixed elements */
        
        /* Custom scrollbar styling: purely aesthetic */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background: #1e40af; /* Darker blue */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        /* Smooth transition ensures background color changes look professional */
        body {
            transition: background-color 1s ease;
        }

        /* Custom font for a more document-like feel */
        .tos-text {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
        }

        /* Utility class to center the welcome screen content vertically */
        .h-screen-centered {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Keyframes for the document-shake animation (A future visual enhancement) */
        @keyframes subtle-shake {
            0%, 100% { transform: translate(0); }
            25% { transform: translate(-0.5px, 0.5px); }
            50% { transform: translate(0.5px, -0.5px); }
            75% { transform: translate(-0.5px, -0.5px); }
        }

        /* ===== Glitch / Breakdown visual styles ===== */
        /* Respect users who prefer reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .glitch-mode * {
                transition: none !important;
                animation: none !important;
            }
        }

        .glitch-mode {
            /* intense background clash */
            background: repeating-linear-gradient(45deg, #070707 0 2px, #1a1a1a 2px 6px), radial-gradient(circle at 20% 10%, rgba(255,0,80,0.12), transparent 18%);
            color: transparent !important; /* base text will be replaced by scrambled layers via JS */
            overflow: hidden;
            filter: contrast(140%) saturate(160%);
        }

        .glitch-mode .tos-text {
            /* heavier blur + high contrast to make text illegible */
            filter: blur(2.6px) contrast(180%) saturate(200%);
            mix-blend-mode: difference;
            letter-spacing: 0.6px;
        }

        /* layered offset text pseudo effect for headings */
        .glitch-mode .glitch-heading {
            position: relative;
        }
        .glitch-mode .glitch-heading::before,
        .glitch-mode .glitch-heading::after {
            content: attr(data-text);
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0.8;
        }
    .glitch-mode .glitch-heading::before { color: #ff0066; transform: translate(-6px, -3px) skewX(-6deg); mix-blend-mode: screen; opacity:0.9; }
    .glitch-mode .glitch-heading::after  { color: #00ffff; transform: translate(6px, 3px) skewX(6deg); mix-blend-mode: multiply; opacity:0.9; }

        /* quick hue-shift and jitter */
        @keyframes hue-jitter { 0% { filter: hue-rotate(0deg) invert(0); } 25% { filter: hue-rotate(180deg) invert(.9); } 50% { filter: hue-rotate(90deg) invert(.4); } 75% { filter: hue-rotate(270deg) invert(.8); } 100% { filter: hue-rotate(0deg) invert(0); } }
        .glitch-mode .tos-text, .glitch-mode p, .glitch-mode h1, .glitch-mode h2 {
            animation: hue-jitter 900ms linear infinite;
        }

        /* scanline / noise overlay used by JS */
        .glitch-scanlines {
            position: fixed;
            inset: 0;
            pointer-events: none;
            mix-blend-mode: overlay;
            background-image: linear-gradient(rgba(0,0,0,0.06) 0 1px, transparent 1px);
            background-size: 100% 4px;
            opacity: 0.9;
            z-index: 9999;
        }

        .glitch-flash {
            position: fixed; inset: 0; pointer-events: none; z-index: 10000;
            background: rgba(255,255,255,0.04);
            mix-blend-mode: screen;
        }

    </style>
</head>
<body class="bg-gray-50 transition-all duration-500">

    <!-- Commitment Meter (Fixed to the top for constant visibility) -->
    <header id="commitment-meter" class="fixed top-0 left-0 right-0 hidden bg-white shadow-xl z-50 p-3 border-b-4 border-blue-600">
        <div class="max-w-4xl mx-auto flex justify-between items-center text-sm font-semibold">
            <div class="text-gray-700">
                <span class="text-blue-600">Depth (Sections Read):</span> <span id="commitment-depth" class="font-extrabold">0</span>
            </div>
            <div class="text-gray-700">
                <span class="text-blue-600">Time Committed:</span> <span id="commitment-time" class="font-extrabold">0s</span>
            </div>
            <!-- Glitch opt-out control -->
            <div class="flex items-center space-x-2 text-xs text-gray-600">
                <input id="glitch-opt-out" type="checkbox" class="h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500" />
                <label for="glitch-opt-out" class="select-none">Disable visual breakdown</label>
            </div>
        </div>
    </header>

    <!-- Main Content Wrapper - Given a stable ID to avoid null reference errors -->
    <div id="main-content-wrapper" class="max-w-4xl mx-auto p-6 md:p-10">

        <!-- Welcome/Data Entry Screen (Initial State) -->
        <div id="welcome-screen" class="h-screen-centered">
            <!-- ... HTML for Welcome Screen ... -->
            <div class="w-full max-w-md p-10 bg-white shadow-2xl rounded-2xl text-center">
                <h1 class="text-4xl font-extrabold text-gray-900 mb-4">
                    Project Genesis: Initiate Agreement
                </h1>
                <p class="text-lg text-gray-600 mb-8">
                    To proceed with the **'Infinite Commitment Protocol'**, define your unique Identifier and accept the pre-terms.
                </p>

                <div class="w-full space-y-4">
                    <!-- Data Entry Field -->
                    <input id="user-identifier" type="text" placeholder="Enter Your Project Name (e.g., 'Midterm Success')"
                           class="w-full p-3 border-2 border-blue-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150" />

                    <!-- Pre-Term Checkbox -->
                    <div class="flex items-center space-x-2 justify-center">
                        <input id="pre-term-check" type="checkbox" class="h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <label for="pre-term-check" class="text-sm text-gray-700 select-none">I understand this process may affect my future timeline.</label>
                    </div>

                    <!-- Start Button -->
                    <button id="start-button"
                            class="w-full py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 disabled:opacity-50 transition duration-150 shadow-lg shadow-blue-500/50"
                            disabled>
                        ACCEPT & BEGIN ENDLESS AGREEMENT
                    </button>
                    <p id="error-message" class="text-red-500 text-sm hidden">Please check the box and provide an identifier to continue.</p>
                </div>
            </div>
        </div>

        <!-- TOS Content Application (Hidden initially) -->
        <!-- pt-16 ensures the content starts below the fixed Commitment Meter -->
        <div id="tos-app-container" class="hidden min-h-screen pt-16">
            <h1 id="main-title" class="text-3xl md:text-5xl font-extrabold text-blue-800 mb-4 transition-all duration-500">
                Endless User Agreement
            </h1>
            <p class="text-lg text-gray-600 mb-8 border-b pb-4">
                The terms below are subject to continuous, dynamic revision based on the User's passive commitment to scroll.
                <span id="complexity-display" class="font-semibold text-red-500 block mt-2">Current Complexity Level: 0</span>
            </p>

            <div id="terms-container" class="space-y-6 tos-text">
                <!-- Content will be added here by JavaScript -->
            </div>

            <!-- Loading Indicator shown while new content is generating -->
            <div id="loading-indicator" class="hidden text-center py-12">
                <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full"></div>
                <p class="text-blue-500 mt-3">Generating more terms... (This will never stop)</p>
            </div>
        </div>
    </div>

    <script>
        // =================================================================
        // GLOBAL VARIABLES AND CONSTANTS
        // =================================================================

        // 1. UI Elements (DOM Manipulation)
        // We use 'const' (constant) for these variables because they will always reference the same HTML element.
        // document.getElementById() is how JavaScript finds and connects to specific elements in your HTML.
        const welcomeScreen = document.getElementById('welcome-screen');
        const tosAppContainer = document.getElementById('tos-app-container');
        const commitmentMeter = document.getElementById('commitment-meter');
        const termsContainer = document.getElementById('terms-container');
        const mainTitle = document.getElementById('main-title');
        const complexityDisplay = document.getElementById('complexity-display');
        const loadingIndicator = document.getElementById('loading-indicator');
        const startButton = document.getElementById('start-button');
        const identifierInput = document.getElementById('user-identifier');
        const preTermCheck = document.getElementById('pre-term-check');
        const errorMessage = document.getElementById('error-message');
        const commitmentDepth = document.getElementById('commitment-depth');
        const commitmentTime = document.getElementById('commitment-time');
        
        // ADDED: Stable reference to the main content wrapper
        const mainContentWrapper = document.getElementById('main-content-wrapper');

        // 2. Core State Management (The Brain of the App)
        const SCROLL_THRESHOLD = 200; // BASE scroll distance (in pixels) from the bottom to trigger generation.
        const MAX_COMPLEXITY = 15; // The level at which visual distortion/chaos maxes out.

        // Variables that change (State)
        let complexityLevel = 0; // Tracks how many clauses have been added. This is the main complexity metric.
        let isGenerating = false; // Flag to prevent generating multiple clauses at once while scrolling.
        let userIdentifier = ''; // Stores the name entered by the user.

    // ===== Glitch / Breakdown state =====
    let glitchActive = false; // whether glitch mode is currently running
    let scrambleInterval = null; // interval handle for text scrambling
    let jitterInterval = null; // interval for element jitter
    let randomTriggerY = null; // the random scroll position that will trigger the glitch
    const textNodesBackup = new Map(); // store original text for restoration
    const OPT_OUT_KEY = 'glitchOptOut';
    // additional intense-mode controls
    let flashInterval = null; // rapid screen flash toggling
    let overlayEl = null; // DOM element for scanlines
    let flashEl = null; // DOM element for subtle flashes

        // 3. Timer State for Commitment Meter
        let startTime = null; // Stores the moment the user clicked 'Start' (a timestamp).
        let timerInterval = null; // Stores the reference to the running timer so we can stop/update it.

        // =================================================================
        // CONTENT DEFINITIONS (You can modify the HTML content here)
        // =================================================================

        // Array containing the structured HTML for the initial clauses.
        const contentLevels = [
            // Level 1: Personalized Introduction - [IDENTIFIER] placeholder will be replaced with user input.
            `<section class="p-4 bg-blue-50 rounded-lg">
                <h2 class="font-bold text-xl mb-2">1. Acceptance of Terms (Agreement for [IDENTIFIER])</h2>
                <p>By using this service, specifically created for the project titled "<strong>[IDENTIFIER]</strong>," you agree to be bound by these Terms of Service (the "Terms"). These Terms govern your access to and use of all Services provided by Us. Read them carefully.</p>
             </section>`,

            // Level 2: Attention Span clause. Adding nested 'div's for complexity.
            `<section class="p-4 bg-gray-100 rounded-lg">
                <h2 class="font-bold text-lg mb-2">2. User Responsibilities and Attention Span</h2>
                <p>You agree to provide accurate, current, and complete information required for the Service, including but not limited to, the average duration of your current thought process. Failure to disclose this exact time in milliseconds constitutes a breach.</p>
                <div class="mt-3 ml-4 p-2 border-l-4 border-blue-400 text-sm">
                    <strong>2.1 Data Collection:</strong> We reserve the right to collect passive usage data, specifically the rate of cursor movement and the frequency of your sighing while reading these Terms.
                </div>
             </section>`,

            // Level 3: Emotional Cost clause. Introducing *emphasis* and ambiguity.
            `<section class="p-4 bg-blue-100 rounded-lg">
                <h2 class="font-bold text-lg mb-2">3. Indemnification and Emotional Cost</h2>
                <p>You agree to indemnify and hold harmless the Service, its affiliates, and their respective officers, agents, and employees from any claims, damages, or expenses arising from your use of the Service, or <em>any interpretation thereof</em>, including the emotional toll incurred during the process.</p>
             </section>`,

             // Level 4: Volatility and Retroactivity. Visually denser using smaller text classes (text-xs, text-sm).
             `<section class="p-6 bg-yellow-50 rounded-lg text-sm">
                <h2 class="font-bold text-base mb-2 text-yellow-800">4. Modification and Re-modification (The Loop)</h2>
                <p><strong>4.1. Clause Volatility:</strong> The Service reserves the right to modify these Terms at any time, including the precise moment you finish reading this sentence. Your continued use of the Service after any modification will mean that you accept the new Terms, even if you do not know what the new Terms are.</p>
                <p class="mt-2 text-xs text-gray-500"><strong>4.2. Retroactive Application:</strong> Any modification may be applied retroactively to your initial agreement, including the exact moment you first considered clicking "I Agree" on any platform in the last calendar year.</p>
             </section>`,
             
             // Level 5: Arbitrary Jurisdiction. Uses a grid (columns) for visual complexity.
             `<section class="p-6 bg-red-50 rounded-lg">
                <h2 class="font-bold text-xl mb-4 text-red-600">5. Governing Law and Arbitrary Jurisdiction</h2>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <p class="font-semibold">5.1. Location:</p>
                        <p>This agreement shall be governed by the laws of a jurisdiction that is yet to be determined but will be inconvenient for you to travel to, specifically an unpaved road in a fictional dimension.</p>
                    </div>
                    <div>
                        <p class="font-semibold">5.2. Dispute Resolution:</p>
                        <p>All disputes must be settled by a game of rock-paper-scissors where the Service's agent is always permitted to choose "rock" and you must choose between "paper" or "existential dread."</p>
                    </div>
                </div>
             </section>`,
        ];

        // =================================================================
        // UI AND FLOW CONTROL FUNCTIONS
        // =================================================================

        /**
         * Checks if the required input (identifier and checkbox) is complete.
         * If both are valid, the start button is enabled.
         */
        function checkFormValidity() {
            const identifierFilled = identifierInput.value.trim().length > 0;
            const preTermAccepted = preTermCheck.checked;
            // The button is DISABLED if NOT (filled AND accepted).
            startButton.disabled = !(identifierFilled && preTermAccepted);
            
            // Hides the error message if the user fixes the input
            if (errorMessage.classList.contains('block')) {
                errorMessage.classList.add('hidden');
            }
        }

        /**
         * Starts the time tracker when the user begins the agreement.
         */
        function startTimer() {
            startTime = Date.now(); // Records the current time in milliseconds.
            // setInterval calls updateCommitmentMeter every 1000ms (1 second).
            timerInterval = setInterval(updateCommitmentMeter, 1000);
        }

        /**
         * Updates the "Depth" and "Time Committed" display in the fixed header.
         */
        function updateCommitmentMeter() {
            if (startTime) {
                // Calculate elapsed time
                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                
                // Update the text content of the meter elements
                commitmentTime.textContent = `${elapsedSeconds}s`;
                commitmentDepth.textContent = complexityLevel;
            }
        }

        /**
         * This function runs when the user clicks 'ACCEPT & BEGIN'.
         * It switches the UI view and initiates the core app logic.
         */
        function startAgreement() {
            const identifier = identifierInput.value.trim();
            // Basic input validation
            if (!identifier || !preTermCheck.checked) {
                errorMessage.classList.remove('hidden');
                return;
            }

            userIdentifier = identifier;
            
            // 1. Transition the view (Hiding the welcome screen and showing the TOS area)
            welcomeScreen.classList.add('hidden');
            tosAppContainer.classList.remove('hidden');
            commitmentMeter.classList.remove('hidden');

            // 2. Start core logic
            startTimer();

            // Example backend call: demonstrate a serverless API request.
            // This shows how the frontend can call a backend endpoint (hosted on Vercel under /api).
            fetch(`/api/hello?identifier=${encodeURIComponent(userIdentifier)}`)
                .then(response => response.json())
                .then(data => {
                    const info = document.createElement('div');
                    info.className = 'my-4 p-3 bg-green-50 border-l-4 border-green-400 text-sm rounded';
                    info.textContent = `${data.message} (server time: ${new Date(data.timestamp).toLocaleString()})`;
                    // Show the API response at the top of the TOS container
                    tosAppContainer.prepend(info);
                })
                .catch(err => {
                    console.error('API call failed', err);
                });

            generateNewTerms(); // Loads the very first clause
            // Choose a random trigger point (a Y offset) that will cause visuals to break down
            // Assumption: 'random point' == a random scroll position during this session.
            // We pick something between 25% and 80% of the current scrollable height so it feels unpredictable.
            try {
                const totalScrollable = Math.max(0, document.documentElement.scrollHeight - window.innerHeight);
                const minPos = Math.floor(totalScrollable * 0.25);
                const maxPos = Math.floor(totalScrollable * 0.8);
                randomTriggerY = Math.floor(Math.random() * Math.max(1, (maxPos - minPos))) + minPos;
            } catch (e) {
                randomTriggerY = 800; // fallback
            }

            // The most important part: start listening for scrolling!
            window.addEventListener('scroll', handleScroll);
            window.addEventListener('scroll', checkGlitchTrigger);
        }


        // ===== Glitch control functions =====
        function checkGlitchTrigger() {
            // Do nothing if user opted out
            try {
                if (localStorage.getItem(OPT_OUT_KEY) === 'true') return;
            } catch (e) { /* ignore storage errors */ }

            if (glitchActive) return;
            if (randomTriggerY == null) return;

            if (window.scrollY >= randomTriggerY) {
                enableGlitch();
            }
        }

        function enableGlitch() {
            if (glitchActive) return;
            // Respect reduced-motion preference
            const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            if (prefersReduced) return; // do not enable

            glitchActive = true;
            document.body.classList.add('glitch-mode');

            // Mark headings so CSS pseudo elements can copy text
            document.querySelectorAll('#main-title, #terms-container h2, #terms-container h1').forEach(h => {
                h.classList.add('glitch-heading');
                h.setAttribute('data-text', h.textContent || '');
            });

            // Intense mode: start fast scrambling and aggressive jitter
            // Scramble very frequently and replace a large fraction of characters
            scrambleInterval = setInterval(scrambleAllText, 80);

            // Aggressive jitter: larger offsets
            jitterInterval = setInterval(randomizeJitter, 90);

            // Add a scanline/noise overlay for CRT-ish disruption
            overlayEl = document.createElement('div');
            overlayEl.className = 'glitch-scanlines';
            document.body.appendChild(overlayEl);

            // Add a subtle flashing element that will be toggled to increase anxiety
            flashEl = document.createElement('div');
            flashEl.className = 'glitch-flash';
            flashEl.style.opacity = '0';
            document.body.appendChild(flashEl);

            // Flash intermittently with random intensity
            flashInterval = setInterval(() => {
                const o = 0.03 + Math.random() * 0.28; // brief 0.03-0.31 overlay
                flashEl.style.transition = 'opacity 110ms linear';
                flashEl.style.opacity = String(o);
                setTimeout(() => { if (flashEl) flashEl.style.opacity = '0'; }, 120 + Math.random()*200);
            }, 220 + Math.random()*300);
        }

        function disableGlitch() {
            if (!glitchActive) return;
            glitchActive = false;
            document.body.classList.remove('glitch-mode');

            // stop intervals
            if (scrambleInterval) {
                clearInterval(scrambleInterval);
                scrambleInterval = null;
            }
            if (jitterInterval) {
                clearInterval(jitterInterval);
                jitterInterval = null;
            }

            if (flashInterval) {
                clearInterval(flashInterval);
                flashInterval = null;
            }

            // remove overlay elements
            try { if (overlayEl && overlayEl.parentNode) overlayEl.parentNode.removeChild(overlayEl); } catch (e) {}
            overlayEl = null;
            try { if (flashEl && flashEl.parentNode) flashEl.parentNode.removeChild(flashEl); } catch (e) {}
            flashEl = null;

            // restore text content
            restoreAllText();

            // clean up heading attributes
            document.querySelectorAll('.glitch-heading').forEach(h => {
                h.classList.remove('glitch-heading');
                h.removeAttribute('data-text');
            });
        }

        function scrambleAllText() {
            // Replace a fraction of characters in each text node inside the terms container
            const nodes = [];
            function walk(node) {
                node.childNodes.forEach(child => {
                    if (child.nodeType === Node.TEXT_NODE && child.textContent.trim().length > 3) {
                        nodes.push(child);
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        walk(child);
                    }
                });
            }
            walk(termsContainer);

            // Intensified glyph set and heavier scramble: 40-85% of characters replaced
            const glyphs = '█▒░▓@#%&*+=?!/<>—~()[]{}<>•○●◆◇▲▼∆⌘≈≠≡';
            nodes.forEach(textNode => {
                // backup original text once
                if (!textNodesBackup.has(textNode)) {
                    textNodesBackup.set(textNode, textNode.textContent);
                }
                const orig = textNodesBackup.get(textNode) || '';
                // occasionally prepend/append random glyph noise for extra chaos
                const prefix = Math.random() < 0.12 ? glyphs[Math.floor(Math.random()*glyphs.length)] : '';
                const suffix = Math.random() < 0.12 ? glyphs[Math.floor(Math.random()*glyphs.length)] : '';
                const chars = orig.split('');
                // scramble 40-85% of chars randomly (more aggressive)
                const scrambleCount = Math.max(1, Math.floor(chars.length * (0.4 + Math.random() * 0.45)));
                for (let i = 0; i < scrambleCount; i++) {
                    const idx = Math.floor(Math.random() * chars.length);
                    chars[idx] = glyphs[Math.floor(Math.random() * glyphs.length)];
                }
                // randomly uppercase or inject spacing to further reduce legibility
                for (let i = 0; i < chars.length; i++) {
                    if (Math.random() < 0.06) chars[i] = chars[i].toUpperCase();
                    if (Math.random() < 0.03) chars[i] = chars[i] + ' ';
                }
                textNode.textContent = prefix + chars.join('') + suffix;
            });
        }

        function restoreAllText() {
            // restore backed-up originals
            textNodesBackup && textNodesBackup.forEach && textNodesBackup.forEach((val, node) => {
                try { node.textContent = val; } catch (e) { /* ignore */ }
            });
        }

        function randomizeJitter() {
            // apply tiny transforms to some sections for chaotic layout
            document.querySelectorAll('#terms-container section').forEach((sec, i) => {
                // much larger offsets for intense effect
                const base = (i % 3 === 0 ? 22 : 10);
                const dx = (Math.random() - 0.5) * base;
                const dy = (Math.random() - 0.5) * base;
                const rot = (Math.random() - 0.5) * 6;
                sec.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg) skew(${(Math.random()-0.5)*4}deg, ${(Math.random()-0.5)*4}deg)`;
                sec.style.transition = 'transform 120ms linear';
                // occasionally nudge opacity and blur
                sec.style.opacity = String(0.6 + Math.random() * 0.6);
                sec.style.filter = 'blur(' + (1 + Math.random()*3) + 'px)';
            });
        }

        // =================================================================
        // CORE LOGIC FUNCTIONS
        // =================================================================

        /**
         * Dynamically adjusts the visual style of the page based on complexityLevel.
         * This is where you modify the visual complexity (colors, font size, layout).
         */
        function updateVisualComplexity() {
            // This line cleans up old classes before adding new ones, preventing conflicts.
            document.body.className = document.body.className.split(' ').filter(c => !c.startsWith('bg-') && c !== 'animate-shake').join(' ');

            // Use the modulus operator (%) to loop visual changes after MAX_COMPLEXITY
            const adjustedLevel = complexityLevel % MAX_COMPLEXITY;
            const title = document.getElementById('main-title');
            
            // Fix: Use the stable ID reference instead of querying by a dynamic class.
            const container = mainContentWrapper; 

            if (adjustedLevel < 4) {
                // Stage 1: Calm State (Simple Background)
                document.body.classList.add('bg-gray-50');
                title.className = "text-3xl md:text-5xl font-extrabold text-blue-800 mb-4 transition-all duration-500";
            } else if (adjustedLevel < 8) {
                // Stage 2: Introducing Stress (Color Shift)
                document.body.classList.add('bg-red-50');
                title.classList.add('text-red-600');
            } else if (adjustedLevel < 12) {
                // Stage 3: Increasing Density (High Contrast & Smaller Text)
                document.body.classList.add('bg-black', 'text-white');
                document.body.style.fontSize = '14px'; // Inline style to shrink all text
                title.classList.remove('text-blue-800', 'text-red-600');
                title.classList.add('text-white', 'text-2xl', 'md:text-4xl', 'font-thin');
            } else {
                // Stage 4: Maximum Chaos (Pulse effect, tiny text)
                document.body.classList.add('bg-yellow-200');
                title.classList.add('text-purple-900', 'animate-pulse');
                document.body.style.fontSize = '12px';
            }

            // Update complexity display text
            complexityDisplay.textContent = `Current Complexity Level: ${complexityLevel}`;
            
            // Change the main content container width (shrinking content)
            // Fix: container is now the mainContentWrapper, guaranteed not to be null.
            container.classList.remove('max-w-4xl', 'max-w-3xl', 'max-w-2xl', 'max-w-full');
            if (adjustedLevel < 5) {
                container.classList.add('max-w-4xl');
            } else if (adjustedLevel < 10) {
                container.classList.add('max-w-3xl');
            } else {
                // Full width, packed text
                container.classList.add('max-w-full', 'px-2');
            }
        }

        /**
         * Generates and appends a new section of the Terms of Service.
         */
        function generateNewTerms() {
            if (isGenerating) return; // Stop if already generating

            isGenerating = true;
            loadingIndicator.classList.remove('hidden');

            // SetTimeout simulates a small delay (0.5 seconds) to show the 'loading' state
            setTimeout(() => {
                complexityLevel++;
                updateVisualComplexity();
                updateCommitmentMeter();

                let newContent = '';
                // Cycles through the predefined contentLevels array using the modulus operator
                const baseIndex = (complexityLevel - 1) % contentLevels.length;
                const identifierReference = `(${userIdentifier.substring(0, 5)})`; // Shortened identifier for chaos

                if (complexityLevel <= contentLevels.length) {
                    // Use a predefined level, and substitute the [IDENTIFIER] placeholder
                    newContent = contentLevels[baseIndex].replace(/\[IDENTIFIER\]/g, userIdentifier);

                } else {
                    // Chaos Generation: When complexity is greater than the predefined content
                    const chaosFactor = Math.floor(complexityLevel / contentLevels.length);
                    
                    // Extracts the text content from a base section to repeat (makes it seem familiar)
                    const fragment = contentLevels[baseIndex].replace(/<[^>]+>/g, '');
                    const fragmentLength = fragment.length;

                    // Building the chaotic HTML section
                    let generatedText = `<section class="p-4 rounded-xl border border-dashed ${chaosFactor % 3 === 0 ? 'bg-indigo-100' : 'bg-white'} text-xs">`;
                    generatedText += `<h2 class="font-bold text-lg mb-2 text-indigo-800">Section ${complexityLevel}. Recursive Commitment (Level ${chaosFactor}) ${identifierReference}</h2>`;

                    // Loop to generate dense, repeated paragraphs
                    for (let i = 0; i < chaosFactor; i++) {
                        const alignment = i % 2 === 0 ? 'text-left' : 'text-center'; // Alternating alignment for visual confusion
                        // Shrinking text size based on chaos factor
                        generatedText += `<p class="mt-1 leading-tight ${alignment} text-${Math.max(8, 16 - chaosFactor)}px">Your commitment to project **${userIdentifier}** is irrevocably documented in this clause. ${fragment.substring(0, Math.min(fragmentLength, 100 + (i * 20)))}... The terms are continuous. The commitment is continuous. </p>`;
                    }

                    generatedText += '</section>';
                    newContent = generatedText;
                }

                // Inserts the new HTML content at the end of the terms container
                termsContainer.insertAdjacentHTML('beforeend', newContent);

                loadingIndicator.classList.add('hidden');
                isGenerating = false;
            }, 500);
        }

        /**
         * This function is the heart of the "infinite" effect. It checks if the user is near the bottom.
         */
        function handleScroll() {
            if (isGenerating) return;

            // 1. Dynamic Scroll Threshold (The "trap" effect)
            // The distance required to trigger generation shrinks as complexity increases (10px less per level).
            // This makes the terms generate faster and faster the longer you read.
            const dynamicThreshold = Math.max(50, SCROLL_THRESHOLD - (complexityLevel * 10));

            // 2. Calculate distance from the bottom
            // document.documentElement.scrollHeight: total height of the document.
            // window.innerHeight: height of the visible browser window.
            // window.scrollY: how far the user has scrolled down.
            const scrollDistance = document.documentElement.scrollHeight - window.innerHeight - window.scrollY;

            // 3. Trigger Condition
            if (scrollDistance < dynamicThreshold) {
                generateNewTerms();
            }
        }

        // =================================================================
        // INITIALIZATION
        // =================================================================

        // window.onload ensures that all HTML elements are loaded before the JavaScript attempts to run.
        window.onload = () => {
            // Event Listeners: These attach the functions above to user actions.
            // 'click' event: When the start button is clicked, run startAgreement().
            startButton.addEventListener('click', startAgreement);
            // 'input' event: When the text box changes, run checkFormValidity().
            identifierInput.addEventListener('input', checkFormValidity);
            // 'change' event: When the checkbox state changes, run checkFormValidity().
            preTermCheck.addEventListener('change', checkFormValidity);
            
            // Runs once on load to set the initial state of the button (disabled).
            checkFormValidity();

            // Initialize glitch opt-out control (persisted)
            const glitchOptEl = document.getElementById('glitch-opt-out');
            try {
                if (glitchOptEl) {
                    // If the user prefers reduced motion, default to opt-out
                    const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                    const stored = localStorage.getItem(OPT_OUT_KEY);
                    if (stored === null && prefersReduced) {
                        localStorage.setItem(OPT_OUT_KEY, 'true');
                    }
                    const isOptOut = localStorage.getItem(OPT_OUT_KEY) === 'true';
                    glitchOptEl.checked = !!isOptOut;
                    glitchOptEl.addEventListener('change', (e) => {
                        try { localStorage.setItem(OPT_OUT_KEY, e.target.checked ? 'true' : 'false'); } catch (err) {}
                        if (e.target.checked) disableGlitch();
                    });
                }
            } catch (err) { /* ignore storage errors */ }
        };
    </script>
</body>
</html>